= simple_form_for contest, html: { class: "b-form edit contest #{contest.strategy_type}" } do |f|
  - if contest.errors.any?
    .b-errors
      .subheadline Ошибки
      .block
        == contest.errors.full_messages.join('<br>')

  .subheadline Общее
  .block
    = f.input :description, as: :hidden
    = f.input :title
    = f.input :member_type, as: :select, collection: Contest.member_type.options, include_blank: false, disabled: contest.persisted?
    = f.input :strategy_type, as: :select, collection: Contest.strategy_type.options, include_blank: false, disabled: contest.started? || contest.finished?
    = f.input :user_vote_key, as: :select, collection: [:can_vote_1, :can_vote_2, :can_vote_3], include_blank: false, hint: 'Не должно быть голосований, запущенных в одно время с одинаковым ключём. Иначе галочка в меню будет неправильно работать.'

  .cc-2
    .c-column
      .subheadline Длительность
      = f.input :matches_per_round, disabled: contest.started? || contest.finished?,
        hint: (contest.swiss? ? 'Для швейцарской системы эту цифру желательно подобрать таким образом, чтобы каждый раунд разбивался не более, чем на три равных блока. Для 72 участников это будет 12, для 60 - 10.' : ''),
        input_html: { min: 1 }
      = f.input :suggestions_per_user, disabled: contest.started? || contest.finished?, input_html: { min: 1 }
      = f.input :matches_interval, disabled: contest.started? || contest.finished?, input_html: { min: 1 }
      = f.input :match_duration, disabled: contest.started? || contest.finished?, input_html: { min: 1 }
      = f.input :started_on, disabled: contest.started? || contest.finished?, start_year: [contest.started_on.year, Date.today.year].min, end_year: [contest.started_on.year, Date.today.year + 1].max

      - if contest.rounds.any?
        span.action-misc При изменении этих параметров голосования будут перетасованы.

    .c-column
      - if contest.persisted?
        .subheadline Статус
        .block
          p.m5 = t("Contest.#{contest.state}")

        - if contest.object.can_propose? || contest.can_start? || contest.can_stop_propose?
          .subheadline Действия
          .contest_actions
            - if contest.object.can_propose?
              a.action href="#{propose_contest_url contest}" data-method="post" Начать приём кандидатов от пользователей

            - if contest.can_stop_propose?
              a.action href="#{cleanup_suggestions_contest_url contest}" data-method="post" Очистить голоса пользователей от накруток
              a.action href="#{stop_propose_contest_url contest}" data-method="post" Остановить приём кандидатов от пользователей

            - if contest.can_start?
              a.action href="#{build_contest_url contest}"  data-method="post"
                - if contest.rounds.empty?
                  | Сгенерировать голосования
                - else
                  | Перетасовать голосования
              - if contest.can_start? & contest.rounds.any?
                a.action href="#{start_contest_url contest}" data-method="post" data-confirm="Вы уверены? После запуска ничего изменить уже будет нельзя!" Запустить турнир
              span.action-misc Действия перезагружают страницу без сохранения прочих изменений.

              - if contest.links.count < Contest::MINIMUM_MEMBERS
                span.action-misc.warn Для старта должно быть минимум #{Contest::MINIMUM_MEMBERS} аниме
              - elsif contest.links.count > Contest::MAXIMUM_MEMBERS
                span.action-misc.warn Для старта должно быть максимум #{Contest::MAXIMUM_MEMBERS} аниме
              /- elsif Contest.all.any?(&:started?)
                span.action-misc.warn Для старта не должно быть других запущенных опросов

              span.action-misc.warn После старта ничего изменить будет нельзя!

            /- if contest.can_finish?
              /a.action href="#{finish_contest_url(contest)}" data-confirm="Вы уверены?" Остановить
              /span.action-misc действие перезагрузит страницу без сохранения прочих изменений

      - if contest.rounds.any?
        .subheadline Турнирная сетка
        .block_m.grid
          a href="#{grid_contest_url contest}" title="Турнирная сетка" Перейти →

  - if contest.persisted?
    - if contest.created? || contest.proposing?
      .block
        - if contest.anime?
          input.member-suggest.subheadline-input.downgrade_landscape type="text" placeholder="Название аниме" data-variant_name="contest[member_ids][]" data-autocomplete="#{autocomplete_animes_url search: ''}"
        - else
          input.member-suggest.subheadline-input.downgrade_landscape type="text" placeholder="Имя персонажа" data-variant_name="contest[member_ids][]" data-autocomplete="#{autocomplete_characters_url search: ''}"

        /input.member-suggest.suggest.subheadline-input.common type="text" data-member_type="#{contest.member_type}" data-autocomplete="#{contest.anime? ? autocomplete_animes_url(search: '') : autocomplete_characters_url(search: '')}"
        .subheadline #{contest.anime? ? 'Аниме' : 'Персонажи'}

        = hidden_field_tag 'contest[member_ids][]', ''
        .variants
          - contest.members.uniq(&:id).each do |member|
            .variant
              = check_box_tag 'contest[member_ids][]', member.id, checked: true
              - if contest.anime?
                a.bubbled href="#{anime_url member}"
                  = member.name
                  span.b-bracket-details
                    = member.score
              - else
                a.bubbled href="#{character_url member}" = member.name

            /.variant
              = hidden_field_tag 'members[]', member.id
              a.bubbled href="#{url_for member}"
                = member.name
              - if member.respond_to? :score
                span.b-bracket-details
                  = member.score
              - if contest.created? || contest.proposing?
                span.b-bracket-actions
                  span.item-delete удалить

        p
          | Итого:&nbsp;
          span.members_count = contest.members.count
          | &nbsp;
          span.members_count_label = Russian.p contest.members.count, 'участник', 'участника', 'участников'

    - if contest.suggestions.any?
      .suggestions
        = render 'suggestions', contest: contest

  .actions
    = f.submit contest.persisted? ? 'Сохранить' : 'Создать', class: 'right'

  - if contest.persisted?
    - if contest.rounds.any?
      - contest.rounds.each do |round|
        .block
          .subheadline
            = round.title
          = render 'contest_matches/match_days', contest: contest, matches: contest.grouped_matches(round)

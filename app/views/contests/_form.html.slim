= simple_form_for contest, html: { class: "edit contest #{contest.strategy_type}" } do |f|
  - if contest.errors.any?
    .errors
      .subheadline.red Ошибки
      .subcontent
        == contest.errors.full_messages.join('<br>')
      div

  .subheadline Общее
  .subcontent
    = f.input :description, as: :hidden
    = f.input :title
    = f.input :member_type, as: :select, collection: Contest.member_type.options, include_blank: false, disabled: contest.persisted?
    = f.input :strategy_type, as: :select, collection: Contest.strategy_type.options, include_blank: false, disabled: contest.started? || contest.finished?
    = f.input :user_vote_key, as: :select, collection: [:can_vote_1, :can_vote_2, :can_vote_3], include_blank: false, hint: 'Не должно быть голосований, запущенных в одно время с одинаковым ключём. Иначе галочка в меню будет неправильно работать.'

  .two-columns.m30
    .column
      .subheadline Длительность
      .subcontent
        = f.input :matches_per_round, disabled: contest.started? || contest.finished?, hint: (contest.swiss? ? 'Для швейцарской системы эту цифру желательно подобрать таким образом, чтобы каждый раунд разбивался не более, чем на три равных блока. Для 72 участников это будет 12, для 60 - 10.' : '')
        = f.input :suggestions_per_user, disabled: contest.started? || contest.finished?
        = f.input :matches_interval, disabled: contest.started? || contest.finished?
        = f.input :match_duration, disabled: contest.started? || contest.finished?
        = f.input :started_on, disabled: contest.started? || contest.finished?, start_year: [contest.started_on.year, Date.today.year].min, end_year: [contest.started_on.year, Date.today.year + 1].max

        - if contest.rounds.any?
          span.action-misc При изменении этих параметров голосования будут перетасованы.

    .column
      - if contest.persisted?
        .subheadline Статус
        .subcontent
          p.m5 = t("Contest.#{contest.state}")

        - if contest.object.can_propose? || contest.can_start? || contest.can_stop_propose?
          .subheadline Действия
          .subcontent.actions
            - if contest.object.can_propose?
              a.action href="#{propose_contest_url contest}" data-method="post" Начать приём кандидатов от пользователей

            - if contest.can_stop_propose?
              a.action href="#{stop_propose_contest_url contest}" data-method="post" Остановить приём кандидатов от пользователей

            - if contest.can_start?
              a.action href="#{build_contest_url contest}"  data-method="post"
                - if contest.rounds.empty?
                  | Сгенерировать голосования
                - else
                  | Перетасовать голосования
              - if contest.can_start? & contest.rounds.any?
                a.action href="#{start_contest_url contest}" data-method="post" data-confirm="Вы уверены? После запуска ничего изменить уже будет нельзя!" Запустить турнир
              span.action-misc Действия перезагружают страницу без сохранения прочих изменений.

              - if contest.links.count < Contest::MINIMUM_MEMBERS
                span.action-misc.warn Для старта должно быть минимум #{Contest::MINIMUM_MEMBERS} аниме
              - elsif contest.links.count > Contest::MAXIMUM_MEMBERS
                span.action-misc.warn Для старта должно быть максимум #{Contest::MAXIMUM_MEMBERS} аниме
              /- elsif Contest.all.any?(&:started?)
                span.action-misc.warn Для старта не должно быть других запущенных опросов

              span.action-misc.warn После старта ничего изменить будет нельзя!

            /- if contest.can_finish?
              /a.action href="#{finish_contest_url(contest)}" data-confirm="Вы уверены?" Остановить
              /span.action-misc действие перезагрузит страницу без сохранения прочих изменений

      - if contest.rounds.any?
        .subheadline Турнирная сетка
        .subcontent.grid
          a href="#{grid_contest_url contest}" title="Турнирная сетка" Перейти →

  - if contest.persisted?
    - if contest.created? || contest.proposing?
      input.member-suggest.suggest.subheadline-input.common type="text" data-member_type="#{contest.member_type}" data-autocomplete="#{contest.anime? ? autocomplete_animes_url(search: '') : autocomplete_characters_url(search: '')}"

      .subheadline #{contest.anime? ? 'Аниме' : 'Персонажи'}
      .subcontent
        = hidden_field_tag "members[]", ''
        ul.container.m5
          - contest.members.uniq(&:id).each do |member|
            li
              = hidden_field_tag 'members[]', member.id
              a href="#{url_for member}" class="bubbled" data-remote="true"
                = member.name
              - if member.respond_to? :score
                span.b-bracket-details
                  = member.score
              - if contest.created? || contest.proposing?
                span.b-bracket-actions
                  span.item-delete удалить

      p
        | Итого:&nbsp;
        span.members-count #{contest.members.count}
        | &nbsp;участников

    - if contest.suggestions.any?
      .suggestions
        = render 'contests/suggestions', contest: contest

  p.buttons.m30
    span.save.button
      = contest ? 'Сохранить' : 'Создать'
  .clearfix

  - if contest.persisted?
    - if contest.rounds.any?
      - contest.rounds.each do |round|
        .subheadline
          = round.title
        .subcontent
          = render 'contest_matches/match_days', contest: contest, matches: contest.grouped_matches(round)
